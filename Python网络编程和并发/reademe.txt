1.OSI模型
OSI网络体系结构分为7层
    ① 物理层       网卡
    ② 数据链路层   交换机   单位为帧
    ③ 网络层       路由
    ④ 传输层       送信
    ⑤ 会话层       定制通话的方式和规则
    ⑥ 表示层       规定数据交换的格式
    ⑦ 应用层       用户的应用程序和网络之间的接口

2.TCP/IP模型
    TCP:传输层的协议
    IP:网络层的协议

3.协议
    协议也叫网络协议，是通信计算机双方必须遵循的一组约定
    三要素：语法，语义，时序
    常用的协议：网络层协议IP，传输层协议TCP和UDP,应用层协议HTTP
    IP:IPV4  IPV6
    IP地址:网络地址和主机地址组成
    IP地址的分类：
        ① A类地址：1个字节的网络地址 3个字节的主机地址
        ③ B类地址：2个字节的网络地址 2个字节的主机地址
        ③ C类地址：3个字节的网络地址 1个字节的主机地址
            用于局域网 例如：192.168.1.234  192.168.1：网路地址  234：主机地址
        ④ D类地址：第一个字节以'1110'开始，是一个专门保留的地址  用于广播
        ⑤ E类地址：以'1111'开始，为将来使用保留  供实验和开发使用
        ⑥ 私有IP
            范围：
                10.0.0.0 ~ 10.255.255.255
                172.16.0.0 ~ 172.31.255.255
                192.168.0.0 ~ 192.168.255.255
        IP地址在127.0.0.1 ~ 127.255.255.255 用于回路测试

    子网掩码：规定了IP地址中的主机地址在0~255之间变化
        例如：
            255.255.255.0
            255.255.255 为网络地址
            0为主机地址   范围是0~255

4.TCP/UDP协议
    TCP:传输控制协议
        特点：面向连接，提供可靠的字节流服务
    UDP：用户数据报协议
        特点：面向数据报的传输层协议 提供非面向连接 不可靠的数据流传输 UDP不提供可靠性 也不提供报文到达确认
    这两种协议是传输层最重要的两种协议，为上层用户提供级别的通信可靠性
    TCP和UDP的最大区别是TCP是面向连接的，UDP是无连接的

    面向连接的TCP：TCP协议是一种可靠的，一对一的，面向有连接的通信协议
    '面向连接'：在正式通信前必须要与对方建立起连接
    通道的建立 ----- > 三次握手
        ① 在建立通道时，客户端首先要向服务端发送一个SYN同步信号
        ② 服务端接收到这个信号后会向客户端发出SYN同步信号和ACK确认信号
        ③ 当服务端的ACK和SYN到达客户端后，客户端与服务端之间的这个'通道'就被建立起来

    通道的关闭 ----> 四次挥手
        ① 在数据传输完毕后，客户端会向服务端发出一个FIN终止信号
        ② 服务端收到这个信号后会向客户端发送一个ACK确认信号
        ③ 如果服务端此后也没有数据发给客户端时服务端会向客户端发送一个FIN终止信号
        ④ 客户端收到这个信号之后，会回复一个确认信号，服务端接收到这个信号后，服务端与客户端之间的通道关闭

    无连接的UDP协议：UDP协议是一种不可靠的，面向无连接，可以实现多对一，一对多和一对一连接的通信协议

5.HTTP协议
    HTTP协议是一个应用层的协议，是一个简单的请求-响应协议  基于TCP
    请求和响应消息的头以ASCII码形式给出
    消息内容具有一个类似MIME的格式
    HTTP协议是基于客户/服务器模式，面向连接
    HTTP事务处理过程：
        ① 客户与服务器建立连接
        ② 客户向服务器发送请求
        ③ 服务器接手请求，并根据请求返回相应的文件作为应答
        ④ 客户与服务器关闭连接
    客户与服务器之间的连接是一次性连接，限制每次只处理一个请求
    HTTP是一种无状态协议
    客户在一个特定的TCP端口(端口一般为80)上打开一个套接字，如果服务器一直在这个周知的端口上，倾听连接

6.端口
    端口：设备与外界交流的出口
    端口就像是一个房子的门，是出入这间房子的必经之路
    在Linux系统中，端口可以有65536(2的16次方)之多
    端口只有整数，范围从0~65535
    知名端口从0~1024
        80端口分配给HTTP服务
        21端口分配给FTP服务
        22端口分配给SSH协议
    动态端口从1024~65535
    win系统查看端口状态：
        netstat -an

7.BS/CS结构
    CS结构是Client/Server的缩写
    BS结构是Browser/Server的缩写

8.Socket
    Socket也叫套接字
    Socket在应用层和传输层之间
    Socket是一组接口，用来网络编程

二.python Socket编程
   1.创建Socket
        import socket
        参数：
            第一个参数：
            address family:  AF_INET(常用) 用于Internet之间的通信  AF_UNIX 用于同一台机器之间的进程通信
            第二个参数：
            Type:套接字类型
            SOCK_STREAM  流式套接字，用于TCP协议
            SOCK_DGRAM   数据报套接字 用于UDP协议
        s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print(s1)
        # UDP协议
        s2 = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

   2.socket发送消息
        分别创建socket的客户端和服务端
            客户端：
                ① 创建客户端的socket
                ② 确定目标服务器的ip地址和端口号
                ③ 对要发送的消息进行编码，编码为bytes形式
                ④ 发送消息
                ⑤ 关闭套接字,节省系统资源
            服务端：
                ① 创建服务端的socket
                ② 创建服务端的ip和端口 如果一个计算机有多个网卡，就有很多个ip，使用空字符串代替ip
                ③ 绑定Ip和端口
                ④ 接收客户端发送的信息,信息需要解码
                ⑤ 关闭套接字,节省系统资源

   3.echo发送消息
        对socket发送消息进行一个改进
            分别创建socket的客户端和服务端
            客户端和服务端需要使用while循环，服务端为死循环
            客户端：
                ① 创建客户端的socket
                ② 确定目标服务器的ip地址和端口号
                ③ 对要发送的消息进行编码，编码为bytes形式
                ④ 发送消息
                ⑤ 接收服务器返回的信息，信息需要解码
                ⑥ 是否退出客户端
                ⑦ 关闭套接字,节省系统资源
            服务端：
                ① 创建服务端的socket
                ② 创建服务端的ip和端口 如果一个计算机有多个网卡，就有很多个ip，使用空字符串代替ip
                ③ 绑定Ip和端口
                ④ 接收客户端发送的信息,信息需要解码
                ⑤ 将客户端发送的信息返回给客户端
                ⑥ 关闭套接字,节省系统资源

三.TFTP
    TFTP：简单文件传输协议,是TCP/IP协议族中一个用来在客户端和服务端进行简单文件传输的协议
    特点：
        ① 简单
        ② 占用资源小
        ③ 适合在局域网进行文件传递
        ④ 端口号为69 默认监听69端口
        ⑤ 基于UDP实现
    如果发送的文件较大，服务器会多次发送，因为发送的次数过多，为了让客户端对接收到的数据进行排序，
    在服务端发送多个字节数据的同时，会发送2个字节的数据，用来存储序号，放在多个字节数据的前面，序号从1开始

    因为需要从服务器上下载文件， 文件可能不存在，此时服务器就会发送一个错误的信息过来，为了区分发送的
    是文件内容还是错误的信息，又用了2个字节表示这个数据包的功能【即操作码】，在序号的前面
    操作码             功能
    1                 读请求，即下载
    2                 写请求，即上传
    3                 表示数据包，即DATA
    4                 确认码，即ACK
    5                 错误
    数据包的格式:
        读写请求[客户端---》服务器]：操作码(2个字节) + 文件名(n个字节) + 0(1个字节) + 模式(n个字节) + 0(1个字节)
        数据包【服务器--->客户端】：操作码(2个字节) + 块编号(2个字节) + 数据(512)
        ACK[客户端---》服务器]：操作码(2个字节) + 块编号(2个字节)
        ERROR【服务器--->客户端】:操作码(2个字节) + 差错码(2个字节) + 差错信息(n个字节) + 0(1个字节)

四.TCP
    服务端的流程:
        ① socket创建一个套接字
        ② bind绑定ip和port
        ③ listen使用套接字变为被动链接
        ④ accept等待客户端的链接
            accept返回两个值，一个是新的socket,一个客户端地址  阻塞函数
        ⑤ recv/send接收发送数据
            recv一般用于TCP协议
    客户端：
        ① 创建一个套接字
        ② 使用connect(ip, addres)链接服务器的ip和端口
        ③ 客户端发送数据 send
        ④ 客户端也可以接收数据 recv

五.黏包
    黏包：黏包指的是数据与数据之间没有明确的分界线，导致不能正确读取数据
    UDP不会黏包，但是会丢失数据，不可靠
    TCP可靠，但是会黏包
    TCP在三种情况下会出现黏包:
        ① 当单个数据包较小时接收方可能一次性读取了多个数据包的数据
        ② 当单个数据包较大时接收方可能一次性仅读取了多个包的一部分数据
        ③ 另外TCP协议为了提高效率，增加了一种优化机制，会将数据较小且发送间隔较短的数据合并发送，该机制也会
        导致发送方将两个数据包黏在一起发送
    黏包最主要的原因：
        ① 接收方不知道消息之间的界限，不知道一个消息需要提取多少字节的数据所造成的。【服务端出现黏包】
        ② 发送方在发送少量数据并且时间间隔较短的数据时，会将几条数据进行合并发送 【客户端出现黏包】

    黏包问题的解决：
        较为合理的解决方式：
            为字节流加上一个报头，告诉发送的字节流总大小，然后接收端来一个死循环接收完所有数据，用struct
            将序列化的数据长度打包成4个字节，4个字节够用
            